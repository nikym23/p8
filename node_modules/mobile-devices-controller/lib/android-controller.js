"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path_1 = require("path");
const fs_1 = require("fs");
const enums_1 = require("./enums");
const device_1 = require("./device");
const utils_1 = require("./utils");
const OFFSET_DI_PIXELS = 16;
class AndroidController {
    static getAllDevices(verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            AndroidController.checkAndroid();
            // this should be always first.
            const runningDevices = AndroidController.parseRunningDevicesList(verbose);
            const devices = new Map();
            yield AndroidController.parseEmulators(runningDevices, devices);
            yield AndroidController.parseRealDevices(runningDevices, devices);
            return devices;
        });
    }
    static getPhysicalDensity(device) {
        return parseInt(AndroidController.executeAdbCommand(device, "shell wm density").split(":")[1]) * 0.01;
    }
    static getPixelsOffset(device) {
        return Math.floor(OFFSET_DI_PIXELS * AndroidController.getPhysicalDensity(device));
    }
    static startEmulator(emulator, options = "", logPath = undefined) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!emulator.token) {
                emulator.token = AndroidController.emulatorId(emulator.apiLevel) || "5554";
            }
            if (logPath) {
                options = options + " > " + logPath + " 2>&1";
            }
            emulator = yield AndroidController.startEmulatorProcess(emulator, options);
            const result = (yield AndroidController.waitUntilEmulatorBoot(emulator.token, parseInt(process.env.BOOT_ANDROID_EMULATOR_MAX_TIME) || 180000)) === true ? enums_1.Status.BOOTED : enums_1.Status.SHUTDOWN;
            if (result === enums_1.Status.BOOTED) {
                emulator.status = enums_1.Status.BOOTED;
                emulator.startedAt = Date.now();
            }
            const density = AndroidController.getPhysicalDensity(emulator);
            const offsetPixels = AndroidController.getPixelsOffset(emulator);
            emulator.config = {
                density: density,
                offsetPixels: offsetPixels,
            };
            return emulator;
        });
    }
    static unlock(token, password = undefined) {
        let result = "";
        if (password) {
            result = utils_1.executeCommand(`${AndroidController.sendKeyCommand(token, 82)} && ${AndroidController.ADB} -s ${token} shell input text ${password} && ${AndroidController.sendKeyCommand(token, 66)}`);
        }
        else {
            result = utils_1.executeCommand(`${AndroidController.sendKeyCommand(token, 82)} && ${AndroidController.sendKeyCommand(token, 66)}`);
        }
        if (!(result !== undefined && result !== "")) {
            console.error("We couldn't unclock the devie: ", result);
        }
    }
    /**
     * Implement kill process
     * @param emulator
     */
    static kill(emulator) {
        let isAlive = true;
        if (emulator.type === enums_1.DeviceType.EMULATOR) {
            if (emulator.token) {
                AndroidController.executeAdbCommand(emulator, " emu kill");
                isAlive = false;
            }
            if (emulator.pid) {
                try {
                    utils_1.killPid(emulator.pid);
                    if (!utils_1.isWin()) {
                        utils_1.killPid(emulator.pid);
                    }
                    isAlive = false;
                }
                catch (error) {
                }
            }
            if (!isAlive) {
                emulator.status = enums_1.Status.SHUTDOWN;
                emulator.pid = undefined;
            }
        }
    }
    static killAll() {
        utils_1.killProcessByName("qemu-system-i386");
    }
    static restartDevice(device) {
        return __awaiter(this, void 0, void 0, function* () {
            if (device.type === enums_1.DeviceType.EMULATOR) {
                AndroidController.kill(device);
                AndroidController.startEmulator(device);
            }
            else {
                console.log("Not implemented for real device!");
            }
            return device;
        });
    }
    static startAdb() {
        console.log("Start adb");
        utils_1.executeCommand(AndroidController.ADB + " start-server");
    }
    static stopAdb() {
        console.log("Stop adb");
        utils_1.executeCommand(AndroidController.ADB + " kill-server");
    }
    static killAdbProcess() {
        utils_1.killProcessByName("adb.exe");
    }
    isAppRunning(device, appId) {
        const result = AndroidController.executeAdbCommand(device, "shell ps");
        if (result.includes(appId)) {
            return true;
        }
        else {
            return false;
        }
    }
    static startApplication(device, fullAppName) {
        const appId = AndroidController.installApp(device, fullAppName);
        let command = "shell monkey -p " + appId + " 1";
        Promise.resolve(AndroidController.executeAdbCommand(device, command));
    }
    static getInstalledApps(device) {
        const list = AndroidController.executeAdbCommand(device, `shell pm list packages -3`).split("\n");
        return list;
    }
    static isAppInstalled(device, packageId) {
        let isAppInstalled = AndroidController.getInstalledApps(device).filter((pack) => pack.includes(packageId)).length > 0;
        return isAppInstalled;
    }
    static installApp(device, testAppName) {
        const packageId = AndroidController.getPackageId(testAppName);
        let isAppInstalled = AndroidController.isAppInstalled(device, packageId);
        if (isAppInstalled) {
            console.log("Uninstall a previous version " + packageId + " app.");
            AndroidController.uninstallApp(device, packageId);
        }
        const output = AndroidController.executeAdbCommand(device, ` install -r ${testAppName}`);
        console.info(output);
        isAppInstalled = AndroidController.isAppInstalled(device, packageId);
        if (!isAppInstalled) {
            const errorMsg = `Failed to install ${testAppName} !`;
            console.error(errorMsg);
            throw new Error(errorMsg);
        }
        return packageId;
    }
    static uninstallApp(device, appId) {
        // Check if app is installed is removed on purpose!
        AndroidController.stopApp(device, appId);
        if (!appId.includes("appium")) {
            const uninstallResult = AndroidController.executeAdbCommand(device, `uninstall ${appId}`);
            if (uninstallResult.includes("Success")) {
                console.info(appId + " successfully uninstalled.");
            }
            else {
                console.error("Failed to uninstall " + appId + ". Error: " + uninstallResult);
            }
        }
        else {
            console.info("Skip uninstall: " + appId);
        }
    }
    static stopApp(device, appId) {
        AndroidController.executeAdbCommand(device, `shell am force-stop ${appId}`);
    }
    static getScreenshot(device, dir, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            fileName = fileName.endsWith(".pne") ? fileName : `${fileName}.png`;
            const pathToScreenshotPng = `/sdcard/${fileName}`;
            AndroidController.executeAdbCommand(device, `shell screencap ${pathToScreenshotPng}`);
            const fullFileName = path_1.resolve(dir, fileName);
            AndroidController.pullFile(device, pathToScreenshotPng, fullFileName);
            return fullFileName;
        });
    }
    static recordVideo(device, dir, fileName, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            new Promise((res, reject) => __awaiter(this, void 0, void 0, function* () {
                const videoFileName = `${fileName}.mp4`;
                const pathToVideo = path_1.resolve(dir, fileName);
                const devicePath = `/sdcard/${videoFileName}`;
                const prefix = AndroidController.gettokenPrefix(device.type);
                const videoRecoringProcess = child_process_1.spawn(AndroidController.ADB, ['-s', prefix + device.token, 'screenrecord', devicePath]);
                callback().then((result) => {
                    videoRecoringProcess.kill("SIGINT");
                    AndroidController.pullFile(device, devicePath, pathToVideo);
                    console.log(result);
                    res(pathToVideo);
                }).catch((error) => {
                    reject(error);
                });
            }));
        });
    }
    static getPackageId(appFullName) {
        return AndroidController.runAaptCommand(appFullName, "package:");
    }
    static pullFile(device, remotePath, destinationFile) {
        const destinationFolder = path_1.dirname(destinationFile);
        // Verify remotePath
        const remoteBasePath = remotePath.substring(0, remotePath.lastIndexOf("/"));
        const sdcardFiles = AndroidController.executeAdbCommand(device, " shell ls -la " + remoteBasePath);
        if (sdcardFiles.includes("No such file or directory")) {
            const error = remoteBasePath + " does not exist.";
            console.log(error);
            return undefined;
        }
        if (!fs_1.existsSync(destinationFolder)) {
            console.log(`The folder ${destinationFolder} doesn't exist!`);
            return undefined;
        }
        // Pull files
        const output = AndroidController.executeAdbCommand(device, "pull " + remotePath + " " + destinationFile);
        console.log(output);
        const o = output.toLowerCase();
        if ((o.includes("error")) || (o.includes("failed")) || (o.includes("does not exist"))) {
            const error = "Failed to transfer " + remotePath + " to " + destinationFolder;
            console.log(error);
            console.log("Error: " + output);
            return undefined;
        }
        else {
            console.log(remotePath + " transferred to " + destinationFile);
        }
        return destinationFile;
    }
    static pushFile(device, fileName, deviceParh) {
        let output = AndroidController.executeAdbCommand(device, "shell mount -o rw,remount -t rootfs /");
        // Verify remotePath
        const remoteBasePath = deviceParh.substring(0, deviceParh.lastIndexOf("/"));
        const sdcardFiles = AndroidController.executeAdbCommand(device, "shell ls -la " + remoteBasePath);
        if (sdcardFiles.includes("No such file or directory")) {
            const error = remoteBasePath + " does not exist.";
            console.log(error);
            return undefined;
        }
        // Verify localPath
        fileName = fileName.replace("/", path_1.sep).replace("\\", path_1.sep);
        if (!fs_1.existsSync(fileName)) {
            const error = fileName + " does not exist.";
            console.log(error);
            return undefined;
        }
        // Push files
        output = AndroidController.executeAdbCommand(device, "push " + fileName + " " + deviceParh);
        console.log(output);
        if ((output.toLowerCase().includes("error")) || (output.toLowerCase().includes("failed"))) {
            console.log("Failed to transfer " + fileName + " to " + deviceParh);
            console.log("Error: ", output);
            return undefined;
        }
        else {
            console.log(fileName + " transferred to " + deviceParh);
        }
        return fileName;
    }
    static getAaptPath() {
        let aaptPath = "";
        let aaptExecutableName = "aapt";
        if (utils_1.isWin()) {
            aaptExecutableName += ".exe";
        }
        const androidHome = path_1.resolve(AndroidController.ANDROID_HOME, "build-tools");
        const searchedFiles = utils_1.searchFiles(androidHome, aaptExecutableName);
        aaptPath = searchedFiles[searchedFiles.length - 1];
        return aaptPath;
    }
    static runAaptCommand(appFullName, grep) {
        let value = "";
        let command = AndroidController.getAaptPath() + " dump badging " + appFullName;
        //If os windows use findstr or use grep for all other
        if (utils_1.isWin()) {
            command = command + " | findstr " + grep;
        }
        else {
            command = command + " | grep " + grep;
        }
        const result = utils_1.executeCommand(command);
        // Parse result
        if (result.includes(grep)) {
            value = result.substring(result.indexOf("'") + 1);
            value = value.substring(0, value.indexOf("'"));
        }
        else {
            value = null;
        }
        return value;
    }
    static startEmulatorProcess(emulator, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const process = child_process_1.spawn(AndroidController.EMULATOR, [" -avd ", emulator.name, "-port ", emulator.token, options || " -wipe-data"], {
                shell: true,
                detached: false
            });
            process.stdout.on("data", (data) => {
                console.log(data.toString());
            });
            process.stdout.on("error", (error) => {
                console.log(error.toString());
            });
            emulator.pid = process.pid;
            return emulator;
        });
    }
    static waitUntilEmulatorBoot(deviceId, timeOut) {
        const startTime = new Date().getTime();
        let currentTime = new Date().getTime();
        let found = false;
        console.log("Booting emulator ...");
        while ((currentTime - startTime) < timeOut * 1000 && !found) {
            currentTime = new Date().getTime();
            found = AndroidController.checkIfEmulatorIsRunning(enums_1.DeviceType.EMULATOR + "-" + deviceId);
        }
        if (!found) {
            let error = deviceId + " failed to boot in " + timeOut + " seconds.";
            console.log(error, true);
        }
        else {
            console.log("Emilator is booted!");
        }
        return found;
    }
    static checkIfEmulatorIsRunning(token) {
        let isBooted = utils_1.executeCommand(AndroidController.ADB + " -s " + token + " shell getprop sys.boot_completed").trim() === "1";
        if (isBooted) {
            isBooted = utils_1.executeCommand(AndroidController.ADB + " -s " + token + " shell getprop init.svc.bootanim").toLowerCase().trim() === "stopped";
        }
        return isBooted;
    }
    static parseEmulators(runningDevices, emulators = new Map(), verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            let availableDevices = false;
            const info = utils_1.executeCommand(AndroidController.LIST_AVDS);
            const infoLines = info.split("\n");
            let emulator = null;
            let status = enums_1.Status.SHUTDOWN;
            // Name: Emulator-Api25-Google
            // Path: /Users/progressuser/.android/avd/Emulator-Api25-Google.avd
            // Target: Google APIs (Google Inc.)
            //         Based on: Android 7.1.1 (Nougat) Tag/ABI: google_apis/x86
            //   Skin: 480x800
            // Sdcard: 12M
            infoLines.forEach(line => {
                if (line.toLowerCase().includes("available android")) {
                    status = enums_1.Status.SHUTDOWN;
                }
                if (line.toLowerCase().includes("following android virtual devices could not be loaded")) {
                    status = enums_1.Status.INVALID;
                }
                if (line.toLowerCase().includes("name")) {
                    const name = line.split("Name: ")[1].trim();
                    emulator = new AndroidDevice(name, undefined, enums_1.DeviceType.EMULATOR, undefined, enums_1.Status.SHUTDOWN);
                }
                if (line.includes("Tag/ABI:")) {
                    const apiLevel = /\d+((.|,)\d+)?/gi.exec(line.split("Tag/ABI:")[0].trim());
                    emulator.apiLevel = apiLevel[0];
                }
                if (emulator && emulator.name && emulator.apiLevel) {
                    if (!emulators.has(emulator.name)) {
                        emulators.set(emulator.name, new Array());
                        emulators.get(emulator.name).push(emulator);
                    }
                }
            });
            const busyTokens = new Array();
            runningDevices.forEach((dev) => __awaiter(this, void 0, void 0, function* () {
                if (dev.type === enums_1.DeviceType.EMULATOR) {
                    try {
                        let avdInfo = "";
                        if (!utils_1.isWin()) {
                            const port = dev.token;
                            //const result = executeCommand("ps aux | grep qemu | grep " + port);
                            //avdIfno = result.split("-avd")[1].split(" ")[1].trim();
                            //progressuser    10532  14.1  0.3  4554328  13024 s006  S+   10:15AM  18:21.84 /Users/progressuser/Library/Android/sdk/emulator/qemu/darwin-x86_64/qemu-system-i386 -avd Emulator-Api25-Google
                            avdInfo = utils_1.executeCommand("(sleep 2; echo avd name & sleep 2 exit) | telnet localhost " + port).trim();
                            if (!AndroidController.checkTelnetReport(avdInfo)) {
                                avdInfo = utils_1.executeCommand("(sleep 6; echo avd name & sleep 6 exit) | telnet localhost " + port).trim();
                            }
                            if (!AndroidController.checkTelnetReport(avdInfo)) {
                                avdInfo = utils_1.executeCommand("(sleep 8; echo avd name & sleep 8 exit) | telnet localhost " + port).trim();
                            }
                        }
                        else {
                            // qemu-system-x86_64.exe 9528 Console 1  2 588 980 K Running SVS\tseno  0:01:10 Android Emulator - Emulator-Api25-Google:5564             
                            avdInfo = utils_1.executeCommand("tasklist /v /fi \"windowtitle eq Android*\"");
                        }
                        emulators.forEach((v, k, m) => {
                            if (avdInfo.includes(k)) {
                                v[0].status = enums_1.Status.BOOTED;
                                v[0].token = dev.token;
                                busyTokens.push(dev.token);
                            }
                        });
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
            }));
            if (busyTokens.length === 0) {
                busyTokens.push(5544);
            }
            emulators.forEach((devices, key, map) => {
                devices.forEach(device => {
                    if (!device.token) {
                        const lastToken = Math.max(...busyTokens);
                        const token = lastToken % 2 === 0 ? lastToken + 2 : lastToken + 1;
                        device.token = token.toString();
                        busyTokens.push(token);
                    }
                });
            });
            if (verbose) {
                console.log("Avds lAist: ", info);
                console.log("Parsed emulators: ", emulators);
            }
            return emulators;
        });
    }
    static checkTelnetReport(avdInfo) {
        return avdInfo !== "" && avdInfo.toLowerCase().includes("ok") && avdInfo.toLowerCase().includes("connected to localhost");
    }
    static parseRunningDevicesList(verbose) {
        // examples
        // List of devices attached
        // ce0217125d20e41304     unauthorized usb:337641472X
        // emulator-5566          device product:sdk_phone_x86 model:Android_SDK_built_for_x86 device:generic_x86
        // ce0217125d20e41304     device usb:337641472X product:dreamltexx model:SM_G950F device:dreamlte
        // emulator-5566          device product:sdk_phone_x86 model:Android_SDK_built_for_x86 device:generic_x86
        const runningDevices = utils_1.executeCommand(AndroidController.LIST_DEVICES_COMMAND)
            .replace("List of devices attached", "")
            .trim()
            .split("\n");
        const devices = new Array();
        runningDevices.forEach(line => {
            if (line.trim().includes("device")) {
                if (line.includes(enums_1.DeviceType.EMULATOR.toString().toLowerCase())) {
                    const token = line.split("   ")[0].replace(/\D+/ig, '');
                    devices.push(new AndroidDevice(undefined, undefined, enums_1.DeviceType.EMULATOR, token, enums_1.Status.BOOTED));
                }
                else if (line.includes("unauthorized") || line.includes("usb")) {
                    const token = line.split("   ")[0].trim();
                    let name = undefined;
                    let status = enums_1.Status.SHUTDOWN;
                    if (!line.includes("unauthorized")) {
                        name = line.split("model:")[1].trim().split(" ")[0].trim();
                        status = enums_1.Status.BOOTED;
                    }
                    devices.push(new AndroidDevice(name, undefined, enums_1.DeviceType.DEVICE, token, status));
                }
            }
        });
        if (verbose) {
            console.log("Running devices: ", runningDevices);
        }
        return devices;
    }
    static parseRealDevices(runningDevices, devices = new Map()) {
        runningDevices.forEach(d => {
            if (d.type === enums_1.DeviceType.DEVICE) {
                devices.set(d.name, new Array());
                devices.get(d.name).push(d);
            }
        });
    }
    static emulatorId(platformVersion) {
        return AndroidController._emulatorIds.get(platformVersion.toString());
    }
    static checkAndroid() {
        let avdMangerExt = "";
        let emulatorExt = "";
        if (utils_1.isWin()) {
            avdMangerExt = ".bat";
            emulatorExt = ".exe";
        }
        if (!fs_1.existsSync(AndroidController.AVD_MANAGER + avdMangerExt)) {
            AndroidController.LIST_AVDS = "android list avds ";
        }
        if (!fs_1.existsSync(AndroidController.EMULATOR + emulatorExt)) {
            AndroidController.EMULATOR = "emulator ";
        }
    }
    static executeAdbCommand(device, command) {
        const prefix = AndroidController.gettokenPrefix(device.type);
        return utils_1.executeCommand(`${AndroidController.ADB} -s ${prefix}${device.token} ${command}`);
    }
    static gettokenPrefix(type) {
        return type === enums_1.DeviceType.DEVICE ? "" : "emulator-";
    }
}
AndroidController.ANDROID_HOME = process.env["ANDROID_HOME"] || "";
AndroidController.EMULATOR = path_1.resolve(AndroidController.ANDROID_HOME, "emulator", "emulator");
AndroidController.ADB = path_1.resolve(AndroidController.ANDROID_HOME, "platform-tools", "adb");
AndroidController.LIST_DEVICES_COMMAND = AndroidController.ADB + " devices -l";
AndroidController.AVD_MANAGER = path_1.resolve(AndroidController.ANDROID_HOME, "tools", "bin", "avdmanager");
AndroidController.LIST_AVDS = AndroidController.AVD_MANAGER + " list avd";
AndroidController._emulatorIds = new Map();
// private static loadEmulatorsIds() {
//     AndroidController._emulatorIds.set("4.2", "5554");
//     AndroidController._emulatorIds.set("4.3", "5556");
//     AndroidController._emulatorIds.set("4.4", "5558");
//     AndroidController._emulatorIds.set("5.0", "5560");
//     AndroidController._emulatorIds.set("5.1", "5562");
//     AndroidController._emulatorIds.set("6", "5564");
//     AndroidController._emulatorIds.set("6.", "5564");
//     AndroidController._emulatorIds.set("6.0", "5564");
//     AndroidController._emulatorIds.set("7", "5566");
//     AndroidController._emulatorIds.set("7.", "5566");
//     AndroidController._emulatorIds.set("7.0", "5566");
//     AndroidController._emulatorIds.set("7.1", "5568");
//     AndroidController._emulatorIds.set("7.1.1", "5570");
//     AndroidController._emulatorIds.set("8", "5572");
//     AndroidController._emulatorIds.set("8.", "5572");
//     AndroidController._emulatorIds.set("8.0", "5572");
//     AndroidController._emulatorIds.set("26", "5572");
//     AndroidController._emulatorIds.set("27", "5574");
//     AndroidController._emulatorIds.set("8.1", "5574");
// }
AndroidController.sendKeyCommand = (token, key) => {
    return `${AndroidController.ADB} -s ${token} shell input keyevent ${key}`;
};
exports.AndroidController = AndroidController;
class AndroidDevice extends device_1.Device {
    constructor(name, apiLevel, type, token, status, pid) {
        super(name, apiLevel, type, enums_1.Platform.ANDROID, token, status, pid);
    }
}
exports.AndroidDevice = AndroidDevice;
//# sourceMappingURL=android-controller.js.map